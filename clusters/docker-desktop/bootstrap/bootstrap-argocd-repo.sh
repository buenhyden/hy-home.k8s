#!/usr/bin/env bash
set -euo pipefail

# Bootstrap ArgoCD repository access with SSH key and optional GitHub deploy key.
# Usage:
#   REPO_URL=git@github.com:owner/repo.git ./bootstrap-argocd-repo.sh
# Optional environment variables:
#   REPO_URL, KEY_FILE, ADD_GITHUB_DEPLOY_KEY, GITHUB_REPO (owner/repo), GITHUB_TOKEN

REPO_URL=${REPO_URL:-}
KEY_FILE=${KEY_FILE:-./id_rsa}
ADD_GITHUB_DEPLOY_KEY=${ADD_GITHUB_DEPLOY_KEY:-false}
GITHUB_REPO=${GITHUB_REPO:-}
GITHUB_TOKEN=${GITHUB_TOKEN:-}

# SealedSecret and kubeseal options
CREATE_SEALED_SECRET=${CREATE_SEALED_SECRET:-false}
SEALED_SECRET_FILE=${SEALED_SECRET_FILE:-./clusters/docker-desktop/argocd-git-ssh-sealedsecret.yaml}
APPLY_SEALED=${APPLY_SEALED:-false}
SKIP_CREATE_SECRET=${SKIP_CREATE_SECRET:-false}
KUBESEAL_CONTROLLER_NAME=${KUBESEAL_CONTROLLER_NAME:-sealed-secrets}
KUBESEAL_CONTROLLER_NAMESPACE=${KUBESEAL_CONTROLLER_NAMESPACE:-kube-system}

# Auto-commit and PR options for SealedSecret
COMMIT_SEALED=${COMMIT_SEALED:-false}
GIT_BRANCH=${GIT_BRANCH:-feature/sealed-secrets-$(date +%Y%m%d-%H%M%S)}
CREATE_PR=${CREATE_PR:-true}
GIT_BASE_BRANCH=${GIT_BASE_BRANCH:-main}

if [ -z "$REPO_URL" ]; then
  echo "REPO_URL must be set" >&2
  echo "Usage: REPO_URL=git@github.com:owner/repo.git ./bootstrap-argocd-repo.sh" >&2
  exit 1
fi

if [ ! -f "$KEY_FILE" ]; then
  echo "Generating SSH key: $KEY_FILE"
  ssh-keygen -t rsa -b 4096 -f "$KEY_FILE" -N ""
fi

PUBLIC_KEY_FILE=${KEY_FILE}.pub
PUB_KEY_CONTENT=$(cat "$PUBLIC_KEY_FILE")

if [ "$SKIP_CREATE_SECRET" != "true" ]; then
  echo "Create Kubernetes secret in argocd namespace from private key"
  kubectl -n argocd create secret generic argocd-git-ssh --from-file=sshPrivateKey="$KEY_FILE" --dry-run=client -o yaml | kubectl apply -f -
else
  echo "SKIP_CREATE_SECRET=true set. Not creating plain Kubernetes secret in cluster."
fi

# If requested generate a SealedSecret YAML using kubeseal and optionally apply it
if [ "$CREATE_SEALED_SECRET" = "true" ]; then
  TMP_SECRET_FILE="/tmp/argocd-git-ssh-secret.yaml"
  echo "Generating dry-run secret YAML for sealing: $TMP_SECRET_FILE"
  kubectl -n argocd create secret generic argocd-git-ssh --from-file=sshPrivateKey="$KEY_FILE" --dry-run=client -o yaml > "$TMP_SECRET_FILE"

  if command -v kubeseal >/dev/null 2>&1; then
    echo "kubeseal found â€” creating SealedSecret ($SEALED_SECRET_FILE) using controller $KUBESEAL_CONTROLLER_NAME in namespace $KUBESEAL_CONTROLLER_NAMESPACE"
    set +e
    kubeseal --controller-name="$KUBESEAL_CONTROLLER_NAME" --controller-namespace="$KUBESEAL_CONTROLLER_NAMESPACE" --format=yaml < "$TMP_SECRET_FILE" > "$SEALED_SECRET_FILE"
    KUBESEAL_EXIT=$?
    set -e
    if [ $KUBESEAL_EXIT -ne 0 ]; then
      echo "kubeseal failed to create sealed secret (exit=$KUBESEAL_EXIT). You may need to run kubeseal with --cert or verify the sealed-secrets controller and access." >&2
    else
      echo "SealedSecret written to: $SEALED_SECRET_FILE"
      if [ "$APPLY_SEALED" = "true" ]; then
        echo "Applying SealedSecret to cluster ($SEALED_SECRET_FILE)"
        kubectl apply -f "$SEALED_SECRET_FILE"
      fi

      # Auto-commit and PR creation for SealedSecret
      if [ "$COMMIT_SEALED" = "true" ]; then
        echo "COMMIT_SEALED=true: Creating git branch, committing SealedSecret, and creating PR..."

        # Ensure we're in the git repository root
        GIT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || echo ".")
        cd "$GIT_ROOT"

        # Create and switch to new branch
        git checkout -b "$GIT_BRANCH" 2>/dev/null || git checkout "$GIT_BRANCH"

        # Add and commit the SealedSecret file
        git add "$SEALED_SECRET_FILE"
        git commit -m "chore(secrets): add SealedSecret for ArgoCD Git SSH

Generated by bootstrap-argocd-repo.sh
- Controller: $KUBESEAL_CONTROLLER_NAME
- Namespace: $KUBESEAL_CONTROLLER_NAMESPACE" || echo "Nothing to commit or commit failed"

        # Push the branch
        git push origin "$GIT_BRANCH" || echo "Push failed - you may need to push manually"

        # Create PR using gh CLI if available and CREATE_PR is true
        if [ "$CREATE_PR" = "true" ]; then
          if command -v gh >/dev/null 2>&1; then
            echo "Creating Pull Request using gh CLI..."
            gh pr create \
              --title "chore(secrets): Add SealedSecret for ArgoCD Git SSH" \
              --body "## Summary
Auto-generated SealedSecret for ArgoCD repository access.

**Generated by:** bootstrap-argocd-repo.sh
**Sealed with controller:** $KUBESEAL_CONTROLLER_NAME in $KUBESEAL_CONTROLLER_NAMESPACE

> **IMPORTANT:** Please review the SealedSecret before merging." \
              --base "$GIT_BASE_BRANCH" || echo "PR creation failed - you may need to create it manually"
          else
            echo "gh CLI not found. Please create a PR manually for branch: $GIT_BRANCH"
          fi
        fi
      fi
    fi
  else
    echo "kubeseal not found. Install kubeseal to generate SealedSecret automatically. Skipping SealedSecret generation." >&2
    echo "You can run: kubectl -n argocd create secret generic argocd-git-ssh --from-file=sshPrivateKey=$KEY_FILE --dry-run=client -o yaml | kubeseal --controller-name=$KUBESEAL_CONTROLLER_NAME --controller-namespace=$KUBESEAL_CONTROLLER_NAMESPACE -o yaml > $SEALED_SECRET_FILE"
  fi
fi

echo "Add repo to ArgoCD (requires argocd CLI and access to the ArgoCD server)"
if command -v argocd >/dev/null 2>&1; then
  echo "Adding repo to ArgoCD using SSH private key"
  argocd repo add "$REPO_URL" --ssh-private-key-path "$KEY_FILE" || true
else
  echo "argocd CLI not found; skipping CLI repo add. You can 'argocd repo add $REPO_URL --ssh-private-key-path $KEY_FILE' manually."
fi

if [ "$ADD_GITHUB_DEPLOY_KEY" = "true" ] && [ -n "$GITHUB_REPO" ] && [ -n "$GITHUB_TOKEN" ]; then
  echo "Adding deploy key to GitHub repository $GITHUB_REPO"
  if ! command -v gh >/dev/null 2>&1; then
    echo "gh CLI not found; attempt using GitHub API"
    curl -s -X POST -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" \
      https://api.github.com/repos/"$GITHUB_REPO"/keys -d "{\"title\": \"argocd-deploy-key\",\"key\": \"$PUB_KEY_CONTENT\", \"read_only\": false }" || true
  else
    echo "$PUB_KEY_CONTENT" | gh api repos/"$GITHUB_REPO"/keys --method POST -F title='argocd-deploy-key' -F key="@$PUBLIC_KEY_FILE" -F read_only=false || true
  fi
fi

echo "Done. Public key (for Git host):"
echo "$PUB_KEY_CONTENT"
